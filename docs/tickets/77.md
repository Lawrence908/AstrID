## **ASTR-77: Astronomical Image Processing (P3) - Core domain**

### **Context & Current State**
Image preprocessing services are complete (ASTR-76 ), providing the foundation for advanced astronomical image processing. This ticket implements advanced image processing capabilities using OpenCV and scikit-image for sophisticated image manipulation, normalization, and analysis.

### **Technical Requirements**

**Dependencies**: ASTR-76 (Image Preprocessing Services) -  Complete
**Domain**: Core Domain (Image Processing)
**Estimated Time**: 3 days

### **Implementation Tasks**

1. **Integrate OpenCV for Image Manipulation**
   - Create `src/domains/preprocessing/processors/opencv_processor.py`
   - Implement `OpenCVProcessor` with methods:
     - `apply_morphological_operations(image: ndarray, operation: str, kernel_size: int) -> ndarray`
     - `detect_edges(image: ndarray, method: str, threshold1: float, threshold2: float) -> ndarray`
     - `apply_filters(image: ndarray, filter_type: str, kernel_size: int) -> ndarray`
     - `perform_geometric_transforms(image: ndarray, transform: dict) -> ndarray`
     - `enhance_contrast(image: ndarray, method: str, alpha: float) -> ndarray`
     - `remove_noise(image: ndarray, method: str, strength: float) -> ndarray`
   - Add support for different image formats and color spaces
   - Implement advanced image enhancement algorithms
   - Add performance optimization for large images

2. **Add Scikit-image for Advanced Processing**
   - Create `src/domains/preprocessing/processors/scikit_processor.py`
   - Implement `ScikitProcessor` with methods:
     - `segment_image(image: ndarray, method: str, parameters: dict) -> ndarray`
     - `detect_features(image: ndarray, detector: str, parameters: dict) -> list[dict]`
     - `apply_morphology(image: ndarray, operation: str, footprint: ndarray) -> ndarray`
     - `measure_image_properties(image: ndarray, properties: list[str]) -> dict`
     - `restore_image(image: ndarray, method: str, parameters: dict) -> ndarray`
     - `classify_pixels(image: ndarray, classifier: str, features: ndarray) -> ndarray`
   - Add machine learning-based image processing
   - Implement advanced segmentation algorithms
   - Add feature detection and analysis

3. **Implement Image Normalization and Scaling**
   - Create `src/domains/preprocessing/normalizers/image_normalizer.py`
   - Implement `ImageNormalizer` with methods:
     - `normalize_intensity(image: ndarray, method: str) -> ndarray`
     - `scale_image(image: ndarray, target_size: tuple, method: str) -> ndarray`
     - `normalize_histogram(image: ndarray, method: str) -> ndarray`
     - `apply_z_score_normalization(image: ndarray) -> ndarray`
     - `normalize_to_reference(image: ndarray, reference: ndarray) -> ndarray`
     - `apply_adaptive_normalization(image: ndarray, window_size: int) -> ndarray`
   - Add support for different normalization algorithms
   - Implement adaptive normalization for varying conditions
   - Add normalization quality assessment

4. **Create Preprocessing Result Storage**
   - Create `src/domains/preprocessing/storage/preprocessing_storage.py`
   - Implement `PreprocessingStorage` with methods:
     - `store_processed_image(image: ndarray, metadata: dict, observation_id: UUID) -> str`
     - `retrieve_processed_image(storage_id: str) -> tuple[ndarray, dict]`
     - `store_processing_parameters(parameters: dict, observation_id: UUID) -> str`
     - `retrieve_processing_parameters(observation_id: UUID) -> dict`
     - `store_processing_metrics(metrics: dict, observation_id: UUID) -> str`
     - `archive_processed_data(observation_id: UUID) -> None`
   - Add compression and optimization for storage
   - Implement processing result versioning
   - Add storage analytics and reporting

### **Integration Points**

- **Preprocessing Domain**: Build on ASTR-76 preprocessing services
- **Storage**: Store processed images and metadata in cloud storage
- **Events**: Emit processing completion and failure events
- **API**: Expose image processing capabilities via REST API
- **Monitoring**: Track processing performance and quality metrics

### **Image Processing Pipeline**
```python
@dataclass
class ImageProcessingResult:
    observation_id: UUID
    processed_image: ndarray
    processing_parameters: dict
    processing_metrics: dict
    quality_scores: dict
    processing_time: float
    storage_path: str
    processing_errors: list[str]
```

### **Processing Configuration**
```python
@dataclass
class ImageProcessingConfig:
    opencv_enabled: bool
    scikit_enabled: bool
    normalization_method: str
    scaling_method: str
    quality_threshold: float
    compression_level: int
    parallel_processing: bool
    max_image_size: tuple[int, int]
```

### **API Endpoints to Add**
```python
POST /preprocessing/process/{observation_id}
GET /preprocessing/results/{observation_id}
POST /preprocessing/normalize
POST /preprocessing/scale
GET /preprocessing/metrics/{observation_id}
POST /preprocessing/archive/{observation_id}
```

### **Image Processing Algorithms**
```python
class ProcessingAlgorithm(Enum):
    MORPHOLOGICAL_OPENING = "morphological_opening"
    MORPHOLOGICAL_CLOSING = "morphological_closing"
    EDGE_DETECTION_CANNY = "edge_detection_canny"
    EDGE_DETECTION_SOBEL = "edge_detection_sobel"
    GAUSSIAN_FILTER = "gaussian_filter"
    MEDIAN_FILTER = "median_filter"
    HISTOGRAM_EQUALIZATION = "histogram_equalization"
    ADAPTIVE_THRESHOLD = "adaptive_threshold"
```

### **Error Handling**
- Image processing failure detection and recovery
- Memory management for large images
- Parameter validation and error reporting
- Processing timeout and cancellation handling
- Comprehensive logging for debugging

### **Testing Strategy**
- Unit tests for all processing algorithms
- Integration tests with real astronomical images
- Performance tests for large image processing
- Quality assessment validation tests
- Error handling tests for various failure scenarios

### **Performance Considerations**
- Parallel processing for multiple images
- Memory-efficient processing for large images
- GPU acceleration where available
- Processing result caching and optimization
- Progress tracking for long-running operations
