## **ASTR-81: Anomaly Detection Pipeline (P2) - ML Pipeline**

### **Context & Current State**
U-Net model integration is complete (ASTR-80), providing the ML model foundation. Detection validation logic, result storage, and metrics calculation are already implemented. This ticket completes the anomaly detection service by implementing the detection service layer and integrating all components into a production-ready pipeline.

### **Technical Requirements**

**Dependencies**: ASTR-80 (U-Net Model Integration) -  Complete
**Domain**: ML Pipeline
**Estimated Time**: 3 days

### **Implementation Tasks**

1. **Implement Detection Service Layer** ❌ **NEW TASK**
   - Create `src/domains/detection/services/detection_service.py`
   - Implement `DetectionService` with methods:
     - `process_observation(observation: Observation) -> DetectionResult`
     - `detect_anomalies(image_data: ndarray, model: Model) -> list[Anomaly]`
     - `validate_detections(detections: list[Anomaly], image: ndarray) -> list[Anomaly]`
     - `calculate_detection_confidence(detections: list[Anomaly]) -> list[float]`
     - `filter_detections_by_confidence(detections: list[Anomaly], threshold: float) -> list[Anomaly]`
   - Add batch processing for multiple observations
   - Implement detection result caching and optimization
   - Add detection pipeline monitoring and metrics

2. **Enhance Detection Validation Logic**  **PARTIALLY COMPLETE**
   - Enhance `src/domains/detection/validators/detection_validator.py`
   - Add advanced validation methods:
     - `validate_detection_quality(detection: Anomaly, image: ndarray) -> bool`
     - `check_detection_duplicates(detections: list[Anomaly]) -> list[Anomaly]`
     - `validate_coordinate_bounds(detection: Anomaly, image_shape: tuple) -> bool`
     - `assess_detection_reliability(detection: Anomaly) -> float`
     - `filter_false_positives(detections: list[Anomaly]) -> list[Anomaly]`
   - Add machine learning-based false positive filtering
   - Implement detection quality scoring
   - Add validation rule configuration and customization

3. **Enhance Detection Result Storage**  **PARTIALLY COMPLETE**
   - Enhance `src/domains/detection/storage/detection_storage.py`
   - Add advanced storage methods:
     - `store_detection_result(result: DetectionResult) -> str`
     - `retrieve_detection_result(detection_id: str) -> DetectionResult`
     - `query_detections_by_observation(observation_id: UUID) -> list[DetectionResult]`
     - `query_detections_by_confidence(confidence_min: float, confidence_max: float) -> list[DetectionResult]`
     - `archive_detection_result(detection_id: str) -> None`
   - Add detection result indexing and search
   - Implement detection result versioning
   - Add detection result analytics and reporting

4. **Enhance Detection Metrics Calculation**  **PARTIALLY COMPLETE**
   - Enhance `src/domains/detection/metrics/detection_metrics.py`
   - Add comprehensive metrics:
     - `calculate_detection_precision(detections: list[Anomaly], ground_truth: list[Anomaly]) -> float`
     - `calculate_detection_recall(detections: list[Anomaly], ground_truth: list[Anomaly]) -> float`
     - `calculate_detection_f1_score(detections: list[Anomaly], ground_truth: list[Anomaly]) -> float`
     - `calculate_detection_auc(detections: list[Anomaly], ground_truth: list[Anomaly]) -> float`
     - `calculate_detection_latency(start_time: datetime, end_time: datetime) -> float`
   - Add real-time metrics calculation and monitoring
   - Implement metrics aggregation and reporting
   - Add performance trend analysis

### **Integration Points**

- **U-Net Model**: Use integrated model for anomaly detection
- **Observation Domain**: Process observations from the observation pipeline
- **Storage**: Store detection results in cloud storage
- **Events**: Emit detection completion and failure events
- **API**: Expose detection results via REST API

### **Detection Pipeline Flow**
```python
@dataclass
class DetectionResult:
    detection_id: UUID
    observation_id: UUID
    anomalies: list[Anomaly]
    confidence_scores: list[float]
    processing_time: float
    model_version: str
    validation_status: str
    quality_metrics: dict
    created_at: datetime
```

### **Anomaly Data Structure**
```python
@dataclass
class Anomaly:
    anomaly_id: UUID
    coordinates: tuple[float, float]  # (x, y) pixel coordinates
    world_coordinates: tuple[float, float]  # (ra, dec) world coordinates
    confidence: float
    size: float  # pixel area
    magnitude: float
    classification: str
    metadata: dict
    validation_flags: list[str]
```

### **API Endpoints to Add**
```python
POST /detections/process/{observation_id}
GET /detections/{detection_id}
GET /detections/observation/{observation_id}
GET /detections/search?confidence_min={min}&confidence_max={max}
POST /detections/{detection_id}/validate
GET /detections/metrics/summary
POST /detections/batch-process
```

### **Detection Configuration**
```python
@dataclass
class DetectionConfig:
    model_path: str
    confidence_threshold: float
    batch_size: int
    max_detections_per_image: int
    validation_enabled: bool
    false_positive_filtering: bool
    quality_assessment: bool
    caching_enabled: bool
```

### **Error Handling**
- Model loading and inference failures
- Detection validation error recovery
- Storage operation error handling
- Metrics calculation error handling
- Comprehensive logging for debugging

### **Testing Strategy**
- Unit tests for all detection service methods
- Integration tests with U-Net model
- Detection accuracy validation tests
- Performance tests for batch processing
- Error handling tests for various failure scenarios

### **Performance Considerations**
- Batch processing for multiple observations
- Model inference optimization
- Detection result caching
- Parallel processing for large datasets
- Memory management for large images
