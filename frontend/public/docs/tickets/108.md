## **ASTR-108: Email Notification for Detected Anomalies (P2) - API & Web Interface**

### **Context & Current State**
Anomaly detection pipeline is complete (ASTR-81 ), providing comprehensive detection services with MLflow integration. This ticket implements SendGrid email notification system to alert users when notable anomalies are detected, building on the existing notification infrastructure and alert system patterns already established in the project.

### **Technical Requirements**

**Dependencies**: ASTR-81 (Anomaly Detection Pipeline) -  Complete
**Domain**: API & Web Interface (Notifications)
**Estimated Time**: 2 days

### **Implementation Tasks**

1. **Set Up SendGrid Integration and Configuration**
   - Install SendGrid Python SDK: `pip install sendgrid`
   - Add SendGrid configuration to environment variables:
     - `SENDGRID_API_KEY` - API key for SendGrid authentication
     - `SENDGRID_FROM_EMAIL` - Sender email address
     - `SENDGRID_FROM_NAME` - Sender display name
   - Create `src/infrastructure/notifications/sendgrid_client.py`:
     - Implement `SendGridClient` class with authentication
     - Add methods for sending emails and managing templates
     - Include error handling and retry logic
   - Update `pyproject.toml` with SendGrid dependency

2. **Define Criteria for Notable Anomaly Detection**
   - Create `src/domains/notifications/criteria/anomaly_criteria.py`:
     - Implement `AnomalyNotificationCriteria` class
     - Define configurable thresholds for notable anomalies:
       - Confidence score threshold (default: 0.8)
       - Detection quality score threshold (default: 0.7)
       - Anomaly size threshold (minimum pixel area)
       - Brightness threshold for significant detections
   - Add criteria configuration to environment variables:
     - `NOTIFICATION_CONFIDENCE_THRESHOLD` (default: 0.8)
     - `NOTIFICATION_QUALITY_THRESHOLD` (default: 0.7)
     - `NOTIFICATION_ENABLED` (default: true)
   - Create criteria evaluation service with caching

3. **Create Email Templates for Anomaly Alerts**
   - Design HTML email template in `src/infrastructure/notifications/templates/anomaly_alert.html`:
     - Professional astronomy-themed design
     - Include detection details (coordinates, confidence, quality)
     - Add thumbnail images of detections
     - Include links to dashboard and curation interface
   - Create plain text fallback template
   - Implement template rendering with Jinja2:
     - `src/infrastructure/notifications/templates/renderer.py`
     - Support for dynamic content and personalization
   - Add template versioning and A/B testing support

4. **Implement Notification Service and Integration**
   - Create `src/domains/notifications/services/email_notification_service.py`:
     - Implement `EmailNotificationService` class
     - Integrate with existing detection pipeline from ASTR-81
     - Add notification queuing and batch processing
     - Implement delivery tracking and status updates
   - Update existing notification workers in `src/adapters/workers/curation/curation_workers.py`:
     - Replace mock email notifications with real SendGrid integration
     - Add proper error handling and retry logic
   - Integrate with existing alert system in `src/infrastructure/workflow/monitoring.py`

5. **Implement Notification Toggle and Preferences**
   - Create notification preferences system:
     - `src/domains/notifications/models/notification_preferences.py`
     - User-specific notification settings
     - Channel preferences (email, dashboard, webhook)
     - Frequency controls (immediate, daily digest, weekly)
   - Add API endpoints for managing preferences:
     - `GET /notifications/preferences` - Get user preferences
     - `PUT /notifications/preferences` - Update preferences
     - `POST /notifications/test` - Send test notification
   - Update frontend settings page to include notification controls

6. **Test and Validate Notification Flow**
   - Create comprehensive test suite:
     - Unit tests for SendGrid integration
     - Integration tests for notification service
     - End-to-end tests for complete notification flow
   - Add test email functionality for validation
   - Implement notification delivery monitoring
   - Create notification analytics and reporting

### **Integration Points**

- **Detection Pipeline**: Integrate with ASTR-81 detection services
- **Alert System**: Connect to existing workflow monitoring from ASTR-91
- **User Management**: Integrate with Supabase authentication
- **Frontend**: Update settings page for notification preferences
- **Database**: Use existing alert models from curation domain

### **SendGrid Integration**
```python
from sendgrid import SendGridAPIClient
from sendgrid.helpers.mail import Mail, Email, To, Content, HtmlContent
from typing import List, Dict, Any, Optional
import logging

class SendGridClient:
    """SendGrid email client for AstrID notifications."""
    
    def __init__(self, api_key: str, from_email: str, from_name: str = "AstrID"):
        self.client = SendGridAPIClient(api_key=api_key)
        self.from_email = from_email
        self.from_name = from_name
        self.logger = logging.getLogger(__name__)
    
    async def send_anomaly_alert(
        self,
        recipients: List[str],
        detection_data: Dict[str, Any],
        template_data: Dict[str, Any]
    ) -> Dict[str, Any]:
        """Send anomaly detection alert email."""
        
        try:
            # Render email template
            html_content = await self._render_template(
                "anomaly_alert.html", 
                template_data
            )
            
            # Create email message
            message = Mail(
                from_email=Email(self.from_email, self.from_name),
                to_emails=[To(email) for email in recipients],
                subject=f"ðŸ”­ Anomaly Detected - {detection_data['detection_id'][:8]}",
                html_content=HtmlContent(html_content)
            )
            
            # Send email
            response = self.client.send(message)
            
            return {
                "success": True,
                "message_id": response.headers.get("X-Message-Id"),
                "status_code": response.status_code,
                "recipients": recipients
            }
            
        except Exception as e:
            self.logger.error(f"Failed to send anomaly alert: {e}")
            return {
                "success": False,
                "error": str(e),
                "recipients": recipients
            }
    
    async def _render_template(
        self, 
        template_name: str, 
        data: Dict[str, Any]
    ) -> str:
        """Render email template with data."""
        # Template rendering implementation
        pass
```

### **Anomaly Notification Criteria**
```python
from dataclasses import dataclass
from typing import Dict, Any, Optional
from enum import Enum

class NotificationPriority(str, Enum):
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"

@dataclass
class AnomalyNotificationCriteria:
    """Criteria for determining if an anomaly should trigger notifications."""
    
    # Confidence thresholds
    min_confidence_score: float = 0.8
    min_quality_score: float = 0.7
    
    # Detection characteristics
    min_anomaly_size_pixels: int = 100
    min_brightness_threshold: float = 0.5
    
    # Frequency controls
    max_notifications_per_hour: int = 10
    cooldown_minutes: int = 30
    
    # Priority mapping
    confidence_priority_mapping: Dict[float, NotificationPriority] = None
    
    def __post_init__(self):
        if self.confidence_priority_mapping is None:
            self.confidence_priority_mapping = {
                0.95: NotificationPriority.CRITICAL,
                0.85: NotificationPriority.HIGH,
                0.75: NotificationPriority.MEDIUM,
                0.65: NotificationPriority.LOW
            }
    
    def should_notify(self, detection_data: Dict[str, Any]) -> tuple[bool, NotificationPriority]:
        """Determine if detection should trigger notification."""
        
        confidence = detection_data.get("confidence_score", 0.0)
        quality = detection_data.get("quality_score", 0.0)
        size = detection_data.get("anomaly_size_pixels", 0)
        brightness = detection_data.get("brightness", 0.0)
        
        # Check basic thresholds
        if confidence < self.min_confidence_score:
            return False, NotificationPriority.LOW
        
        if quality < self.min_quality_score:
            return False, NotificationPriority.LOW
        
        if size < self.min_anomaly_size_pixels:
            return False, NotificationPriority.LOW
        
        if brightness < self.min_brightness_threshold:
            return False, NotificationPriority.LOW
        
        # Determine priority based on confidence
        priority = NotificationPriority.LOW
        for threshold, p in sorted(self.confidence_priority_mapping.items(), reverse=True):
            if confidence >= threshold:
                priority = p
                break
        
        return True, priority
```

### **Email Template Structure**
```html
<!-- anomaly_alert.html -->
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>AstrID Anomaly Alert</title>
    <style>
        .container { max-width: 600px; margin: 0 auto; font-family: Arial, sans-serif; }
        .header { background: #1a1a2e; color: white; padding: 20px; text-align: center; }
        .content { padding: 20px; background: #f8f9fa; }
        .detection-card { background: white; border-radius: 8px; padding: 20px; margin: 20px 0; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .priority-high { border-left: 4px solid #dc3545; }
        .priority-medium { border-left: 4px solid #ffc107; }
        .priority-low { border-left: 4px solid #28a745; }
        .btn { display: inline-block; padding: 10px 20px; background: #007bff; color: white; text-decoration: none; border-radius: 4px; }
        .footer { text-align: center; padding: 20px; color: #6c757d; font-size: 12px; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ðŸ”­ AstrID Anomaly Alert</h1>
            <p>New astronomical anomaly detected</p>
        </div>
        
        <div class="content">
            <div class="detection-card priority-{{ priority }}">
                <h2>Detection Details</h2>
                <p><strong>Detection ID:</strong> {{ detection_id }}</p>
                <p><strong>Confidence Score:</strong> {{ confidence_score }}%</p>
                <p><strong>Quality Score:</strong> {{ quality_score }}%</p>
                <p><strong>Coordinates:</strong> RA {{ ra }}, Dec {{ dec }}</p>
                <p><strong>Survey:</strong> {{ survey_name }}</p>
                <p><strong>Detection Time:</strong> {{ detection_time }}</p>
                
                {% if thumbnail_url %}
                <div style="margin: 20px 0;">
                    <img src="{{ thumbnail_url }}" alt="Detection thumbnail" style="max-width: 100%; height: auto;">
                </div>
                {% endif %}
                
                <div style="margin: 20px 0;">
                    <a href="{{ dashboard_url }}" class="btn">View in Dashboard</a>
                    <a href="{{ curation_url }}" class="btn">Review Detection</a>
                </div>
            </div>
        </div>
        
        <div class="footer">
            <p>This is an automated alert from AstrID. To manage notification preferences, visit your <a href="{{ settings_url }}">settings page</a>.</p>
        </div>
    </div>
</body>
</html>
```

### **Notification Service Implementation**
```python
from typing import List, Dict, Any, Optional
from datetime import datetime, timedelta
import asyncio
from src.domains.notifications.criteria.anomaly_criteria import AnomalyNotificationCriteria
from src.infrastructure.notifications.sendgrid_client import SendGridClient
from src.domains.curation.models import Alert, AlertStatus, AlertPriority

class EmailNotificationService:
    """Service for sending email notifications about detected anomalies."""
    
    def __init__(
        self,
        sendgrid_client: SendGridClient,
        criteria: AnomalyNotificationCriteria,
        notification_preferences: Optional[Dict[str, Any]] = None
    ):
        self.sendgrid = sendgrid_client
        self.criteria = criteria
        self.preferences = notification_preferences or {}
        self.logger = logging.getLogger(__name__)
    
    async def process_detection_notification(
        self,
        detection_data: Dict[str, Any],
        recipients: List[str]
    ) -> Dict[str, Any]:
        """Process detection and send notification if criteria met."""
        
        # Check if notification should be sent
        should_notify, priority = self.criteria.should_notify(detection_data)
        
        if not should_notify:
            return {
                "notified": False,
                "reason": "Criteria not met",
                "detection_id": detection_data.get("detection_id")
            }
        
        # Check rate limiting
        if not await self._check_rate_limit(recipients):
            return {
                "notified": False,
                "reason": "Rate limit exceeded",
                "detection_id": detection_data.get("detection_id")
            }
        
        # Prepare template data
        template_data = await self._prepare_template_data(detection_data, priority)
        
        # Send notification
        result = await self.sendgrid.send_anomaly_alert(
            recipients=recipients,
            detection_data=detection_data,
            template_data=template_data
        )
        
        # Log notification in database
        await self._log_notification(detection_data, recipients, result, priority)
        
        return {
            "notified": result["success"],
            "detection_id": detection_data.get("detection_id"),
            "recipients": recipients,
            "priority": priority.value,
            "message_id": result.get("message_id")
        }
    
    async def _prepare_template_data(
        self, 
        detection_data: Dict[str, Any], 
        priority: NotificationPriority
    ) -> Dict[str, Any]:
        """Prepare data for email template rendering."""
        
        return {
            "detection_id": detection_data.get("detection_id", "unknown"),
            "confidence_score": int(detection_data.get("confidence_score", 0) * 100),
            "quality_score": int(detection_data.get("quality_score", 0) * 100),
            "ra": detection_data.get("ra", "N/A"),
            "dec": detection_data.get("dec", "N/A"),
            "survey_name": detection_data.get("survey_name", "Unknown Survey"),
            "detection_time": detection_data.get("detection_time", datetime.utcnow().isoformat()),
            "priority": priority.value,
            "thumbnail_url": detection_data.get("thumbnail_url"),
            "dashboard_url": f"{self.preferences.get('base_url', 'http://localhost:3010')}/dashboard/detections/{detection_data.get('detection_id')}",
            "curation_url": f"{self.preferences.get('base_url', 'http://localhost:3010')}/dashboard/curation/{detection_data.get('detection_id')}",
            "settings_url": f"{self.preferences.get('base_url', 'http://localhost:3010')}/dashboard/settings"
        }
    
    async def _check_rate_limit(self, recipients: List[str]) -> bool:
        """Check if notification rate limit is exceeded."""
        # Implement rate limiting logic
        # Check recent notifications for recipients
        return True
    
    async def _log_notification(
        self,
        detection_data: Dict[str, Any],
        recipients: List[str],
        result: Dict[str, Any],
        priority: NotificationPriority
    ) -> None:
        """Log notification in database."""
        # Create Alert record in database
        # This would integrate with existing Alert model
        pass
```

### **API Endpoints**
```python
# Add to existing API
@router.get("/notifications/preferences")
async def get_notification_preferences(
    current_user: User = Depends(get_current_user)
):
    """Get user notification preferences."""
    return {
        "email_enabled": True,
        "confidence_threshold": 0.8,
        "quality_threshold": 0.7,
        "frequency": "immediate",
        "recipients": ["user@example.com"]
    }

@router.put("/notifications/preferences")
async def update_notification_preferences(
    preferences: dict,
    current_user: User = Depends(get_current_user)
):
    """Update user notification preferences."""
    # Update preferences in database
    return {"success": True, "preferences": preferences}

@router.post("/notifications/test")
async def send_test_notification(
    current_user: User = Depends(get_current_user)
):
    """Send test notification to user."""
    # Send test email
    return {"success": True, "message": "Test notification sent"}
```

### **Environment Configuration**
```bash
# Add to .env file
SENDGRID_API_KEY=your_sendgrid_api_key_here
SENDGRID_FROM_EMAIL=noreply@astrid.example.com
SENDGRID_FROM_NAME=AstrID System

# Notification criteria
NOTIFICATION_CONFIDENCE_THRESHOLD=0.8
NOTIFICATION_QUALITY_THRESHOLD=0.7
NOTIFICATION_ENABLED=true
NOTIFICATION_MAX_PER_HOUR=10
NOTIFICATION_COOLDOWN_MINUTES=30

# Base URLs for links in emails
ASTRID_BASE_URL=http://localhost:3010
ASTRID_API_URL=http://127.0.0.1:8000
```

### **Error Handling and Monitoring**
- SendGrid API error handling and retry logic
- Notification delivery status tracking
- Failed notification alerting and recovery
- Rate limiting and spam prevention
- Comprehensive logging for debugging

### **Testing Strategy**
- Unit tests for SendGrid integration
- Integration tests for notification service
- End-to-end tests for complete notification flow
- Template rendering tests with various data
- Rate limiting and error handling tests

### **Performance Considerations**
- Async notification processing
- Batch email sending for multiple recipients
- Template caching and optimization
- Database query optimization for preferences
- Rate limiting and resource management

### **Expected Deliverables**
1. **SendGrid Integration** - Complete email client implementation
2. **Notification Criteria** - Configurable anomaly detection criteria
3. **Email Templates** - Professional HTML and text templates
4. **Notification Service** - Complete service with database integration
5. **API Endpoints** - User preference management endpoints
6. **Frontend Integration** - Settings page updates
7. **Test Suite** - Comprehensive testing for all components

### **Success Criteria**
- Email notifications are sent when notable anomalies are detected
- Notification criteria are configurable and working correctly
- Email templates render properly with detection data
- User preferences can be managed through API and frontend
- Test notifications can be sent successfully
- Integration with existing AstrID infrastructure is seamless
